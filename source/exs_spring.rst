exs_spring
^^^^^^^^^^

.. index:: exs_spring

:Purpose:

    Show the basic steps in a finite element calculation.

:Description:

    The general procedure in linear finite element calculations is carried out for a simple structure. The steps are:

    * Define the model
    * Generate element matrices
    * Assemble element matrices into the global system of equations
    * Solve the global system of equations
    * Evaluate element forces

    Consider the system of three linear elastic springs, and the corresponding finite element model. The system of springs is fixed in its ends and loaded by a single load :math:`F`.

    .. only:: html
        
        .. figure:: images/exs1_1.svg
            :align: center
            :width: 400px
    
    .. only:: latex
        
        .. figure:: images/exs1_1.svg
            :align: center
            :width: 70%

    .. only:: html
        
        .. figure:: images/exs1_2.svg
            :align: center
            :width: 400px
    
    .. only:: latex
        
        .. figure:: images/exs1_2.svg
            :align: center
            :width: 70%

:Example:

    The computation is initialized by importing CALFEM and NumPy, then defining the topology matrix :code:`Edof` containing the degrees of freedom for each element:

    .. code-block:: python

        >>> import numpy as np
        >>> import calfem.core as cfc

        >>> # Element topology matrix (no element numbers, just DOFs)
        >>> Edof = np.array([
        ...     [1, 2],  # Element 1: DOF 1 to DOF 2
        ...     [2, 3],  # Element 2: DOF 2 to DOF 3  
        ...     [2, 3]   # Element 3: DOF 2 to DOF 3
        ... ])

    The global stiffness matrix :code:`K` (3×3) of zeros:

    .. code-block:: python

        >>> K = np.zeros((3, 3))
        >>> print(K)
        [[0. 0. 0.]
         [0. 0. 0.]
         [0. 0. 0.]]

    And the load vector :code:`f` (3×1) with the load :math:`F=100` at DOF 2:

    .. code-block:: python

        >>> f = np.zeros(3)
        >>> f[1] = 100  # Load at DOF 2 (index 1 in 0-based indexing)
        >>> print(f)
        [  0. 100.   0.]

    Element stiffness matrices are generated by the function :code:`cfc.spring1e`. The element property :code:`ep` for the springs contains the spring stiffnesses :math:`k` and :math:`2k` respectively, where :math:`k=1500`:

    .. code-block:: python

        >>> k = 1500
        >>> ep1 = k      # Spring stiffness for elements 2
        >>> ep2 = 2 * k  # Spring stiffness for elements 1 and 3
        >>> 
        >>> Ke1 = cfc.spring1e(ep1)
        >>> print("Ke1 (k=1500):")
        >>> print(Ke1)
        [[ 1500. -1500.]
         [-1500.  1500.]]
        >>> 
        >>> Ke2 = cfc.spring1e(ep2)
        >>> print("Ke2 (k=3000):")
        >>> print(Ke2)
        [[ 3000. -3000.]
         [-3000.  3000.]]

    The element stiffness matrices are assembled into the global stiffness matrix :code:`K` according to the topology:

    .. code-block:: python

        >>> # Assemble element 1 (uses Ke2 with stiffness 3000)
        >>> K = cfc.assem(Edof[0, :], K, Ke2)
        >>> print("After assembling element 1:")
        >>> print(K)
        [[ 3000. -3000.     0.]
         [-3000.  3000.     0.]
         [    0.     0.     0.]]
        >>> 
        >>> # Assemble element 2 (uses Ke1 with stiffness 1500)
        >>> K = cfc.assem(Edof[1, :], K, Ke1)
        >>> print("After assembling element 2:")
        >>> print(K)
        [[ 3000. -3000.     0.]
         [-3000.  4500. -1500.]
         [    0. -1500.  1500.]]
        >>> 
        >>> # Assemble element 3 (uses Ke2 with stiffness 3000)
        >>> K = cfc.assem(Edof[2, :], K, Ke2)
        >>> print("After assembling element 3:")
        >>> print(K)
        [[ 3000. -3000.     0.]
         [-3000.  7500. -4500.]
         [    0. -4500.  4500.]]

    The global system of equations is solved considering the boundary conditions. DOFs 1 and 3 are fixed (value 0):

    .. code-block:: python

        >>> bc = np.array([[0, 0],   # DOF 1 = 0 (fixed)
        ...                [2, 0]])  # DOF 3 = 0 (fixed)
        >>> a, r = cfc.solveq(K, f, bc)
        >>> print("Displacements:")
        >>> print(a)
        [ 0.          0.01333333  0.        ]
        >>> print("Reaction forces:")
        >>> print(r)
        [-40.   0. -60.]

    Element forces are evaluated from the element displacements. These are obtained from the global displacements :code:`a` using the function :code:`cfc.extract_ed`:

    .. code-block:: python

        >>> # Extract displacements for each element
        >>> ed1 = cfc.extract_ed(Edof[0, :], a)  # Element 1
        >>> ed2 = cfc.extract_ed(Edof[1, :], a)  # Element 2  
        >>> ed3 = cfc.extract_ed(Edof[2, :], a)  # Element 3
        >>> 
        >>> print("Element displacements:")
        >>> print("Element 1:", ed1)
        Element 1: [ 0.          0.01333333]
        >>> print("Element 2:", ed2)
        Element 2: [ 0.01333333  0.        ]
        >>> print("Element 3:", ed3)  
        Element 3: [ 0.01333333  0.        ]

    The spring forces are evaluated using the function :code:`cfc.spring1s`:

    .. code-block:: python

        >>> # Calculate element forces
        >>> es1 = cfc.spring1s(ep2, ed1)  # Element 1 uses ep2 (3000)
        >>> es2 = cfc.spring1s(ep1, ed2)  # Element 2 uses ep1 (1500)
        >>> es3 = cfc.spring1s(ep2, ed3)  # Element 3 uses ep2 (3000)
        >>> 
        >>> print("Spring forces:")
        >>> print("Element 1 force:", es1[0])
        Element 1 force: 40.0
        >>> print("Element 2 force:", es2[0]) 
        Element 2 force: 20.0
        >>> print("Element 3 force:", es3[0])
        Element 3 force: 40.0
